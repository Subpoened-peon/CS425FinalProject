import socket
import threading
import pickle
import sys
import signal
from time import time
from channels import Channel
from threading import Lock

class Server:
    def __init__(self, port=12345, debug_level=0):
        self.host = 'localhost'
        self.port = port
        self.debug_level = debug_level
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((self.host, self.port))
        self.server.listen(5)

        self.clients = {}  # {client_socket: {'nickname': nickname, 'channel': channel}}
        self.channels = {}  # {channel_name: [client_sockets]}
        
        #Lock for threading
        self.clients_lock = Lock()
        self.channels_lock = Lock()

        self.shutdown_time = time() + 180  # Idle timeout (3 minutes)

    def debug(self, message):
        """Print debug messages based on the debug level."""
        if self.debug_level > 0:
            print(message)

    def send_object(self, client_socket, data):
        """Send a Python object to the client."""
        client_socket.send(pickle.dumps(data))

    def receive_object(self, client_socket):
        """Receive a Python object from the client."""
        return pickle.loads(client_socket.recv(1024))

    def broadcast(self, message, channel, sender_socket=None):
        """Send a message to all clients in a channel."""
        for client in self.channels[channel].clients:
            if client != sender_socket:
                try:
                    self.send_object(client, {"type": "message", "data": message})
                except:
                    self.remove_client(client)

    def remove_channel(self, channel_name):
        """Remove a channel from the server."""
        if channel_name in self.channels:
            del self.channels[channel_name]
            self.debug(f"Channel {channel_name} has been deleted.")


    def remove_client(self, client_socket):
        """Remove a client from the server."""
        with self.clients_lock:         # Lock the clients list
            if client_socket in self.clients:
                info = self.clients.pop(client_socket)
                nickname = info['nickname']
                channel = info['channel']
                """This next check sends to the channel to inform any other clients within it that the other client has left"""
                if channel in self.channels and client_socket in self.channels[channel].clients:
                    self.channels[channel].remove_client(client_socket)
                    self.broadcast(f"{nickname} has left the channel.", channel)
        client_socket.close()

    def handle_client(self, client_socket):
        """Handle communication with a single client."""
        self.shutdown_time = time() + 180  # Reset idle timer

        if client_socket not in self.clients:
            self.clients[client_socket] = {'nickname': None, 'channel': None}

        try:
            self.debug(f"Client connected: {client_socket.getpeername()}")
            self.send_object(client_socket, {"type": "message", "data": "Welcome! Use /help for commands."})

            while True:
                data = self.receive_object(client_socket)
                command = data.get("command")
                args = data.get("args", [])

                if command == "nick":
                    nickname = args[0]
                    if nickname in [info['nickname'] for info in self.clients.values()]:
                        self.send_object(client_socket, {"type": "error", "data": "Nickname already in use."})
                    else:
                        with self.clients_lock:
                                self.clients[client_socket] = {"nickname": nickname, "channel": None}
                        self.send_object(client_socket, {"type": "success", "data": f"Nickname set to {nickname}"})

                elif command == "join":
                    # Check if the channel name is provided (generated by chatGPT)
                    if not args or not args[0].strip():
                        self.send_object(client_socket, {"type": "error", "data": "You must specify a channel name to join. Usage: /join <channel_name>."})
                        continue
                    """Sets the channel name to the name the client added in join"""
                    channel_name = args[0]
                    with self.channels_lock:
                        if channel_name not in self.channels:
                            self.channels[channel_name] = Channel(channel_name)
                        channel = self.channels[channel_name]
                    channel.add_client(client_socket)
                    self.clients[client_socket]['current_channel'] = channel_name
                    self.broadcast(f"{nickname} has joined the channel.", channel_name)
                    self.send_object(client_socket, {"type": "success", "data": f"Joined channel {channel}"})

                elif command == "list":
                    """If there are no channels, it doesn't bother searching the list and sends this"""
                    if not self.channels:
                        self.send_object(client_socket, {"type": "message", "data": "No channels available."})
                    else:
                        """Searches for the channels and checks the length of their client lists"""
                        channels_info = "\n".join([f"{ch}: {len(channel.clients)} users" for ch, channel in self.channels.items()])
                        self.send_object(client_socket, {"type": "message", "data": f"Channels:\n{channels_info}"})

                elif command == "leave":
                    if not args or not args[0].strip():
                        self.send_object(client_socket, {"type": "error", "data": "You must specify a channel to leave. Usage: /leave <channel_name>."})
                        continue

                    channel_name = args[0]
                    if channel_name not in self.channels:
                        self.send_object(client_socket, {"type": "error", "data": f"Channel '{channel_name}' does not exist."})
                        continue
                    channel = self.channels[channel_name]
                    if client_socket not in channel.clients:
                        self.send_object(client_socket, {"type": "error", "data": f"You are not in the channel '{channel_name}'."})
                        continue
                    
                    # If the channel being left is the current_channel of the client, set it to None
                    if self.clients[client_socket]['current_channel'] == channel_name:
                        self.clients[client_socket]['current_channel'] = None
    
                    channel.remove_client(client_socket, self)

                    self.send_object(client_socket, {"type": "success", "data": f"You have left the channel '{channel_name}'."})

                elif command == "following":
                    # Get all channels the client belongs to
                    following_channels = [ch for ch, channel in self.channels.items() if client_socket in channel.clients]
    
                    if following_channels:
                        self.send_object(client_socket, {"type": "message", "data": f"Channels you are following: {', '.join(following_channels)}"})
                    else:
                        self.send_object(client_socket, {"type": "message", "data": "You are not currently following any channels."})

                elif command == "quit":
                    break

                elif command == "help":
                    help_text = (
                        "/nick <nickname>: Set your nickname\n"
                        "/join <channel>: Join a channel\n"
                        "/list: List all channels and the number of users\n"
                        "/leave: Leave the current channel\n"
                        "/following: List all channels you are part of\n"
                        "/quit: Disconnect\n"
                    )
                    self.send_object(client_socket, {"type": "message", "data": help_text})

                else:
                    current_channel = self.clients[client_socket].get('current_channel')
                    if current_channel:
                        self.broadcast(f"{nickname}: {data.get('message')}", current_channel, sender_socket=client_socket)
                    else:
                        self.send_object(client_socket, {"type": "error", "data": "Join a channel to chat."})
        except Exception as e:
            self.debug(f"Error: {e}")
        finally:
            self.remove_client(client_socket)

    def start(self):
        print(f"Server started on {self.host}:{self.port}")
        signal.signal(signal.SIGINT, self.graceful_shutdown)

        while True:
            if time() > self.shutdown_time:
                print("Server idle for 3 minutes. Shutting down.")
                self.graceful_shutdown(None, None)

            try:
                client_socket, client_address = self.server.accept()
                threading.Thread(target=self.handle_client, args=(client_socket,)).start()
            except:
                pass

    def graceful_shutdown(self, signum, frame):
        print("Shutting down server.")
        for client in self.clients.keys():
            client.close()
        self.server.close()
        sys.exit(0)

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Chat Server")
    parser.add_argument("-p", type=int, default=12345, help="Port number")
    parser.add_argument("-d", type=int, choices=[0, 1], default=0, help="Debug level (0: errors, 1: all events)")

    args = parser.parse_args()

    server = Server(port=args.p, debug_level=args.d)
    server.start()
